# 传输层

单工：单向传输，比如电视、广播。都是只能单向传输给你，你没法回复电视吧。
半双工：可以双向传输，但是在同一个时间点内，只能单向通信。比如对讲机。
全双工：可以在任意时间点同时双向传输，双向通信。比如电话

1. 位于应用层和网络层之间
2. 是面向连接的、可靠的进程到进程通信的协议
3. TCP将提供双全工服务，即数据可在同一时间双向传播
4. TCP将若干个字节称为一个分组，此分组称为一个报文段(Segment)，也就是说数据在TCP层称做报文段
5. 对可靠性要求高的上层协议，实现可靠性的保证，如果数据丢失、损坏的情况下如何保证可靠性。网络层只管传递数据，成功与否并不关心。

## 传输层的功能

传输层是只有主机才有的层次，中间的网路设备，最多只有三层，只能到网络层。
传输层是为应用层提供通信服务，同时它可以使用网络层的服务。
1. **传输层提供进程和进程之间的逻辑通信。**
我们知道在网络层是实现主机之间的通信(主机与主机之间的逻辑通信)，信息传输到主机即可。但是实际上这并没有通信完全，比如QQ之间进行对话，不能只是传递到对方主机，还需要传递到对方主机的QQ进程上，实现源主机的QQ进程和目标主机的QQ进程之间的通信才算一个完整的通信。

2. **复用和分用**
复用是指发送方不同的应用进程都可以使用同一个传输层传输数据。比如QQ和微信都可以使用同一个传输层协议来进行发送数据。<br/>
分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。是指传输层接收到的是多个进程的数据，比如QQ和微信的，因此需要分别交付给QQ和微信来进行处理，也就是分开处理。

3. **传输层对收到的报文进行差错检测**
在网络层只对报文首部数据进行首部数据和校验，不会对传输数据进行校验，而传输层需要对数据进行检测，这样的话才能够实现对整个数据的校验，确保数据的不出错。
4. **传输层的两个协议：TCP和UDP**
纯属层有两个好兄弟，大哥TCP和二弟UDP，大哥靠谱，二弟不靠谱。
TCP:传送数据之前必须建立连接，数据传送结束之后要释放连接。不提供广播或者多播服务。由于TCP要提供可靠的面向连接的传输服务，因此不可避免地增加了许多开销：回复确认、流程控制、计时器以及连接管理等。**可靠，面向连接，时延大，适用于大文件**<br>
UDP:传送数据之前不需要建立连接，收到UDP报文后也不需要给出任何确认。**不可靠，无连接，时延小，适用于小文件**


### 传输层的寻址和端口
复用：应用层所有的应用进程都可以通过传输层再传输到网络层。
分用：传输层从网络层收到数据后交付指明的应用进程。
#### 端口

那么它是如何找到指明的应用进程。我们知道在网络层是通过IP找到对应的网络，再通过物理地址MAC地址找到对应的主机。
而在传输层也是一样的，通过**端口**来指明找到对应的应用进程。
端口是传输层的SAP，标识主机中的应用进程。每个端口通过一个数字即端口号来进行标识，端口号只有本地意义，在因特网中不同计算机的相同端口号是没有联系的。

端口号长度为16bit，能表示65536个不同的端口号。
![端口号分类](https://ftp.bmp.ovh/imgs/2021/02/01655e47cde73d61.jpg)

#### 套接字socket
在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程。
套接字Socket = (主机IP地址，端口号)


### UDP协议(用户数据报协议)
UPD协议只是在IP数据服务之上增加了很少的功能，即复用分用和差错检测功能。
UDP的主要特点：
1. UDP是无连接的，减少了连接、维持连接，断开连接的开销和发送数据之前的时延（无连接的）
2. UDP使用最大努力交付，即不保证可靠交付（不可靠的）
3. UDP是面向报文的，适合一次性传输少量的数据。所谓的面向报文就是应用层给UDP多长的报文，UDP就照样发送，不会做处理，即一次发送一个完整报文。因此，UDP发送的报文必须是大小合适的报文。否则传输的数据还需要在网络层进行分片，影响网络层的传输。
4. UDP没有拥塞控制，适合很多实时应用。

#### UDP首部格式(8个字节)
16位源端口号：2个字节，16位。源端口号可写可不写，如果想要获取到对方的回复，那么可以写上，否则不需要写。
16位目的端口号：2个字节，16位。必须要有。
16位UDP长度：2个字节，16位。用户数据包的整个长度。包括UDP首部和UDP数据。
16位的UDP检验和：2个字节，16位。检测整个UDP数据报（包括首部字段和数据字段）是否有错，有错就丢弃。
分用时如果找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP“端口不可达”差错报告报文。


### TCP协议

#### TCP特点
1. TCP是面向连接(虚连接)的传输层协议。也就是说应用之间要通信，必须先建立连接。类似于打电话一样，必须接通之后才能通话。
2. 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。因此，TCP协议没办法进行广播或者多播服务。
3. TCP提供可靠交付的服务，无差错、不丢失、不重复和按序到达。
4. TCP提供全双工通信。(发送缓存和接收缓存)
5. TCP是面向字节流的。流是进入到进程或者从进程流出的字节序列。TCP把应用程序交下来的数据看成是一连串的无结构的字节流。
![TCP字节流](https://ftp.bmp.ovh/imgs/2021/02/c834c4a4464ab147.jpg)
如上图所示：假如要发送一个这样的文件，那么TCP会将其按照字节进行编号，比如1，2，3...字节，发送时先将这些字节放入TCP缓存中等待发送，发送时先取其中几个字节组成一个报文段，然后加上TCP头进行发送。


#### TCP报文段首部格式
源端口和目的端口：建立连接所必须的端口号。

序号：本报文段发送数据的首个字节对应的序号，比如这次发送的数据是从3-10，那么序号就是3。

确认号：是期望收到对方的下一个报文段的数据的第一个字节的序号。若确认号为N，表示到序号N-1为止，所有的数据都已正确接收到。

6个控制位：
**紧急位URG(Urgent)**：URG=1时，表明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。（在发送方的紧急处理）
**确认位ACK(Acknowledgemnt)**:ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置位1.
**推送位PSH(Push)**：PSH=1时，接收方尽快交付接收应用程序，不再等到缓存填满再向上交付。（在接收方的紧急处理）
**复位RET(RESET)**:RST=1时，表明TCP连接中出现了严重差错，必须释放连接，然后再重新建立传输连接。

**同步位SYN(Sync)**：SYN=1时，表明是一个连接请求/连接接收报文。
**终止位FIN(Final)**：FIN=1时，表明此报文发送数据已发完，要求释放连接。

窗口：指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。
检验和：检验首部和数据，检验时要加上12B的伪首部，第4个字段为协议字段，TCP的协议字段为6。

![TCP首部字段](https://ftp.bmp.ovh/imgs/2021/02/532f7f9ad864e926.jpg)


#### TCP的连接管理
TCP是面向连接的协议，因此每个TCP连接都有三个阶段：连接建立，数据传送(维持连接)和连接释放。TCP连接的管理就是使运输连接的建立和释放都能够正常进行。
TCP的连接是双工通信，也就是角色是不定的，发送方也可以变成接收方。为了做区分，将主动发起连接建立的应用程序叫做客户，而被动等待连接建立的应用进程叫做服务器。<br>
**TCP连接的建立** <br>
在TCP连接建立的过程中，要解决以下三个问题。
* 要使得每一方都能够确知对方的存在
* 要允许双方协商一些参数（如最大窗口只，是否使用窗口扩大选项等）
* 能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配。

TCP连接的建立要经历以下三个步骤，通常称为3次握手。
1. 客户端的TCP首先向服务器的TCP发送一个连接请求报文段。这个报文段没有应用层数据，其首部字段中的SYN同步位置为1，表示这是一个连接请求;seq=x序号位随机分配一个序号，虽然连接请求不携带数据，但是需要消耗一个序号。（类似于，男生发送：你好，有件事不知当讲不当讲）
2. 服务器的TCP收到连接请求报文段后，如同意建立连接，就像客户端发送确认报文段，并为该TCP连接分配TCP缓存和变量,确认报文没有应用层数据，SYN同步位置为1，表示这是一个确认连接，ACK=1，确认号字段生效，需要设置序号即小写的ack，ack置为x+1，由于没有携带应用层数据，因此序号也是随机分配，seq=y主机随机分配序号字节。（女生回复：当讲，你说吧）
3. 当客户端收到确认报文段后，还要向服务器返回确认的确认，并且也要给该连接分配缓存和变量，SYN=0，SYN只有在连接请求和连接请求确认时才置为1，其他时候置为0。ACK=1，因为第二次握手时发送了ack=y,因此它知道接下来要发送哪个序号，即ack=y+1，seq=x+1,之前已经发送了序号为x的字节，接下来就是x+1（男生回复：好的，既然你说当讲，那我就说了。xxx）于前两个报文段不同的是，这时候可以发送数据了。
![三次握手](https://ftp.bmp.ovh/imgs/2021/02/7b3af9e2a0b39d58.jpg)

ps:TCP连接的建立，之所以这么复杂，是因为TCP连接是可靠连接，必须确保连接是畅通的，双方都可以接收数据，也就是说只有每一个发送放都确保收到回复后才能正常建立连接。因此至少需要进行三次询问和确认。
第一次是客户端问服务器端是否可以发送数据，确保从客户端到服务器端可以正常连接
第二次是对服务器端回复我方，如果服务器端进行了回复，说明它收到了信息，因此表明客户端到服务器端是正常的。
第三次是客户端对服务器端的回复进行回复，客户端收到了服务器端的回复，表明服务器端到客户端是正常的，因此表明连接可以建立，双方都可以发送数据了。


**SYN洪泛攻击**
由于TCP建立连接的过程中会发送SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复地发送ACK给攻击者。这样更加会浪费服务器的资源。如果攻击者对服务器发送大量的这种半连接TCP，由于每一次都没法完成TCP握手，所以在服务器上，这种TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能会死机，就无法为正常用户提供服务了。<br>
解决办法就是：设置SYN cookie。<br>

**TCP连接的释放:四次握手** <br>
参与一条TCP连接的两个进程中的任何一个都能够终止该连接，连接结束后，主机中的“资源”(缓存和变量)将被释放。

第一步：客户端打算关闭连接时，向其TCP发送要给连接释放报文段，并停止发送数据，主动关闭TCP连接。报文段的内容为：
FIN=1：FIN=1表明此报文段的发送方的数据已经发送完毕，并要求释放连接。
seq=u:请求释放报文段一般是不携带数据的，因此,seq给出一个值用来标记该报文即可，取决于之前发送到哪里了。

第二步：服务器收到连接释放报文段后即发出确认，因此，客户端到服务器段的连接就释放了————半关闭状态(连接还是建立的，只是客户端停止发送数据，但是服务器端还是可以照常发送数据)。报文段的具体字段为：
ACK=1，表示确认
seq=v，取决于之前发送到哪里。
ack=u+1；由于之前发送的序号是u，而且不携带内容，因此，下一个按理来说应该是u+1。
此时客户端接收到这个报文段也并不需要进行回复了。

第三步：服务器发送完确认报文段之后，就可以发出连接释放报文段，主动关闭服务器端到客户端的TCP连接。报文段内容：
FIN：1，要求释放连接的标志位
ACK：1，在连接没有断开时，所有ACK都需要置为1
seq:序号是根据之前已经发送的数据的下一个。
ack:u+1。由于客户端没有发送数据，因此确认号是跟上面一样。

第四步：客户端发送一个确认报文段，不是立即结束连接，需要等到时间等待计时器的2MSL(最长报文段寿命)后，连接彻底释放。
ACK:1，
seq:u+1,ack:w+1。
为什么需要等待最长报文段寿命后，才能够释放。如果客户端发送的确认报文段丢失了，没有顺利地发送到服务器端，服务器端没有收到确认报文段，她就会重传第三步的报文段（即连接释放的报文段），客户端就会再发送一个确认报文段,并且重新启动2MSL计时器，如果报文段没有丢失，双方就会进入正常的关闭程序，连接彻底释放。
![TCP的连接释放-四次握手](https://ftp.bmp.ovh/imgs/2021/02/9e15ca07a2335ed0.jpg)

#### TCP的可靠传输
我们都知道，网络层提供的是不可靠传输，因此可靠传输需要依赖它的上一层，也就是传输层，传输层使用TCP来实现可靠传输。

可靠：指的是保证接收方进程从缓存区读取出的字节流与发送方发出的字节流是完全一样的。

**TCP实现可靠传输的四种机制：**<br/>

1. 校验
2. 序号
3. 确认
4. 重传

**校验**：与UDP校验一样，在报文段首部增加伪首部,然后通过二进制反码求和的方法，来判断是否有发生错误。

**序号**：TCP的传输是面向字节流的，每个字节进行一个编号,这个编号就是序号。序号字段是每次传输的报文段(几个序号组成)的第一个序号。有了这些序号，就能够保证数据能够有序地传递过去。

**确认**：为了确保所有的报文段都正确地被接收方接收，接收方在接收到报文段之后，会发送一个确认报文段，这个确认报文段只是确认功能，它的ask=x，x是期待接收的第x个字节流，表示前面x-1个字节都已经正确接收。
![TCP-确认](https://ftp.bmp.ovh/imgs/2021/02/f02b1be49e4d0fc0.jpg)
如果4,5,6被丢失了，那么它发送的确认报文段的确认号字段会始终为4，如果发送方直接发送了，7，8，虽然会正确地接收，但是返回的确认报文段的确认号字段仍然是丢失的字节流的首个序列字段4。这样的话发送方就知道接收方没有顺利接收到4，5，6，因此会重传这个报文段。

**重传**
确认重传不分家，TCP的发送方在规定的时间内没有接收到确认报文段，那么久需要重传已发送的报文段。
快速重传：
每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明写一个期望字节的序号：
比如：发送方已发送1，2，3，4，5报文段。
接收方收到1，返回给1的确认（确认号为2的第一个字节）
接收方收到3，返回给1的确认（确认号为2的第一个字节）
接收方收到4，返回给1的确认（确认号为2的第一个字节）
接收方收到5，返回给1的确认（确认号为2的第一个字节）
我们可以看到，发送方收到了3个对于报文段1的冗余ACK，这时候就会认为2报文段丢失，就回迅速重传2报文段。